"use strict";
/*
    tyronzil-sdk: Tyron DID SDK - Zilliqa's DID-Method at www.tyronZIL.com
    Copyright (C) 2020 Julio Cesar Cabrapan Duarte

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransitionTag = exports.InitTyron = void 0;
const zcrypto = __importStar(require("@zilliqa-js/crypto"));
const Util = __importStar(require("@zilliqa-js/util"));
const zilliqa_init_1 = __importDefault(require("./zilliqa-init"));
const smart_util_1 = __importDefault(require("./smart-contracts/smart-util"));
const ErrorCode_1 = __importDefault(require("../decentralized-identity/util/ErrorCode"));
const document_model_1 = require("../decentralized-identity/protocols/models/document-model");
/** The `init.tyron smart contracts */
var InitTyron;
(function (InitTyron) {
    InitTyron["Testnet"] = "0x63e2d8484187de4f66a571c098f3b51a793f055b";
    InitTyron["Mainnet"] = "0x1c8272a79b5b4920bcae80f310d638c8dd4bd8aa";
    InitTyron["Isolated"] = "0x9ded7118b3386108f1bc4e0e0699d7ab23997265";
})(InitTyron = exports.InitTyron || (exports.InitTyron = {}));
/** The tyronZIL transaction class */
class TyronZIL extends zilliqa_init_1.default {
    constructor(network, contractOwner, userPrivateKey, initTyron, gasPrice, gasLimit) {
        super(network);
        this.contractOwner = contractOwner;
        this.userPrivateKey = userPrivateKey;
        this.initTyron = initTyron;
        this.gasPrice = gasPrice;
        this.gasLimit = gasLimit;
    }
    /** Retrieves the minimum gas price & validates the account info */
    static initialize(network, initTyron, userPrivateKey, gasLimit) {
        return __awaiter(this, void 0, void 0, function* () {
            let CONTRACT_OWNER = zcrypto.getAddressFromPrivateKey(userPrivateKey);
            let GAS_LIMIT = new Util.Long(Number(gasLimit));
            const ZIL_INIT = new zilliqa_init_1.default(network);
            const transaction_init = yield ZIL_INIT.API.blockchain.getMinimumGasPrice()
                .then((min_gas_price) => {
                const GAS_PRICE = new Util.BN(min_gas_price.result);
                return new TyronZIL(network, CONTRACT_OWNER, userPrivateKey, initTyron, GAS_PRICE, GAS_LIMIT);
            })
                .catch((err) => { throw err; });
            return transaction_init;
        });
    }
    /***            ****            ***/
    /** Deploys the DIDC by version
     * & calls the Init transition with the avatar.agent */
    static deploy(agent, input, contractCode) {
        return __awaiter(this, void 0, void 0, function* () {
            const CONTRACT_INIT = [
                {
                    vname: '_scilla_version',
                    type: 'Uint32',
                    value: '0',
                },
                {
                    vname: 'initContractOwner',
                    type: 'ByStr20',
                    value: `${input.contractOwner}`,
                },
                {
                    vname: 'initTyron',
                    type: 'ByStr20',
                    value: `${input.initTyron}`,
                }
            ];
            const CONTRACT = input.API.contracts.new(contractCode, CONTRACT_INIT);
            input.API.wallet.addByPrivateKey(input.userPrivateKey);
            const deployed_contract = yield input.API.blockchain.getBalance(input.contractOwner)
                .then((user_balance) => __awaiter(this, void 0, void 0, function* () {
                const [deployTx, didc] = yield CONTRACT.deploy({
                    version: input.zilVersion,
                    gasPrice: input.gasPrice,
                    gasLimit: input.gasLimit,
                    nonce: Number(user_balance.result.nonce) + 1,
                }, 33, 1000, false);
                const IS_DEPLOYED = deployTx.isConfirmed();
                if (!IS_DEPLOYED) {
                    throw new ErrorCode_1.default("Wrong-Deployment", "The user's DIDC did not get deployed");
                }
                const DEPLOYMENT_GAS = (deployTx.getReceipt()).cumulative_gas;
                // Calling the Init transition
                const INIT_CALL = yield didc.call('Init', [
                    {
                        vname: 'agent',
                        type: 'String',
                        value: `${agent}`
                    }
                ], {
                    version: input.zilVersion,
                    amount: new Util.BN(0),
                    gasPrice: input.gasPrice,
                    gasLimit: input.gasLimit
                }, 33, 1000, false);
                if (!INIT_CALL.isConfirmed()) {
                    throw new ErrorCode_1.default("CodeNotInitialized", "The DIDC did not get initialized");
                }
                const DEPLOYED_CONTRACT = {
                    transaction: deployTx,
                    contract: didc,
                    gas: DEPLOYMENT_GAS,
                    initCall: INIT_CALL
                };
                return DEPLOYED_CONTRACT;
            }))
                .catch(err => { throw err; });
            return deployed_contract;
        });
    }
    /** Submits a tyronZIL transaction */
    static submit(input, didcAddr, tag, params, operation // e.g. ".did"
    ) {
        return __awaiter(this, void 0, void 0, function* () {
            yield input.API.blockchain.getSmartContractState(didcAddr)
                .then((smart_contract_state) => __awaiter(this, void 0, void 0, function* () {
                const OPERATION_COST = smart_contract_state.result.operation_cost;
                return yield smart_util_1.default.getValuefromMap(OPERATION_COST, operation);
            }))
                .then((operation_cost) => __awaiter(this, void 0, void 0, function* () {
                const AMOUNT = new Util.BN(operation_cost);
                const USER_PUBKEY = zcrypto.getPubKeyFromPrivateKey(input.userPrivateKey);
                const USER_BALANCE = yield input.API.blockchain.getBalance(input.contractOwner);
                const TRANSITION = {
                    _tag: tag,
                    _amount: String(AMOUNT),
                    _sender: input.contractOwner,
                    params: params
                };
                const TX_OBJECT = {
                    version: input.zilVersion,
                    amount: AMOUNT,
                    nonce: Number(USER_BALANCE.result.nonce) + 1,
                    gasLimit: input.gasLimit,
                    gasPrice: input.gasPrice,
                    toAddr: didcAddr,
                    pubKey: USER_PUBKEY,
                    data: JSON.stringify(TRANSITION),
                };
                const RAW_TX = input.API.transactions.new(TX_OBJECT);
                return RAW_TX;
            }))
                .then((raw_tx) => __awaiter(this, void 0, void 0, function* () {
                input.API.wallet.addByPrivateKey(input.userPrivateKey);
                const SIGNED_TX = yield input.API.wallet.signWith(raw_tx, input.contractOwner);
                return SIGNED_TX;
            }))
                .then((signed_tx) => __awaiter(this, void 0, void 0, function* () {
                /** Sends the tyronZIL transaction to the Zilliqa blockchain platform */
                const TX = yield input.API.blockchain.createTransaction(signed_tx, 33, 1000);
                return TX;
            }))
                .then((transaction) => __awaiter(this, void 0, void 0, function* () {
                const TRAN_ID = transaction.id;
                const TRANSACTION = yield transaction.confirm(TRAN_ID, 33, 1000);
                const STATUS = transaction.isConfirmed();
                if (!STATUS) {
                    throw new ErrorCode_1.default("TyronZIL", "The ${tag} tyronZIL transaction was unsuccessful!");
                }
                const TX_RECEIPT = transaction.getReceipt();
                return {
                    transaction: TRANSACTION,
                    receipt: TX_RECEIPT
                };
            }))
                .catch((err) => { throw err; });
        });
    }
    static create(agent, document, updateKey, recoveryKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const PARAMS = [];
            const AGENT = {
                vname: 'agent',
                type: 'String',
                value: agent,
            };
            PARAMS.push(AGENT);
            const DOCUMENT = {
                vname: 'document',
                type: 'List Document',
                value: document,
            };
            PARAMS.push(DOCUMENT);
            const UPDATE_KEY = {
                vname: 'updateKey',
                type: 'ByStr33',
                value: updateKey,
            };
            PARAMS.push(UPDATE_KEY);
            const RECOVERY_KEY = {
                vname: 'recoveryKey',
                type: 'ByStr33',
                value: recoveryKey,
            };
            PARAMS.push(RECOVERY_KEY);
            return PARAMS;
        });
    }
    static recover(agent, newDocument, docHash, signature, newUpdateKey, newRecoveryKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const PARAMS = [];
            const AGENT = {
                vname: 'agent',
                type: 'String',
                value: agent,
            };
            PARAMS.push(AGENT);
            const DOCUMENT = {
                vname: 'newDocument',
                type: 'List Document',
                value: newDocument,
            };
            PARAMS.push(DOCUMENT);
            const DOC_HASH = {
                vname: 'docHash',
                type: 'ByStr20',
                value: docHash,
            };
            PARAMS.push(DOC_HASH);
            const SIGNATURE = {
                vname: 'signature',
                type: 'ByStr64',
                value: signature,
            };
            PARAMS.push(SIGNATURE);
            const NEW_UPDATE_KEY = {
                vname: 'newUpdateKey',
                type: 'ByStr33',
                value: newUpdateKey,
            };
            PARAMS.push(NEW_UPDATE_KEY);
            const NEW_RECOVERY_KEY = {
                vname: 'newRecoveryKey',
                type: 'ByStr33',
                value: newRecoveryKey,
            };
            PARAMS.push(NEW_RECOVERY_KEY);
            return PARAMS;
        });
    }
    static update(agent, newDocument, docHash, signature, newUpdateKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const PARAMS = [];
            const AGENT = {
                vname: 'agent',
                type: 'String',
                value: agent,
            };
            PARAMS.push(AGENT);
            const DOCUMENT = {
                vname: 'newDocument',
                type: 'List Document',
                value: newDocument,
            };
            PARAMS.push(DOCUMENT);
            const DOC_HASH = {
                vname: 'docHash',
                type: 'ByStr20',
                value: docHash,
            };
            PARAMS.push(DOC_HASH);
            const SIGNATURE = {
                vname: 'signature',
                type: 'ByStr64',
                value: signature,
            };
            PARAMS.push(SIGNATURE);
            const NEW_UPDATE_KEY = {
                vname: 'newUpdateKey',
                type: 'ByStr33',
                value: newUpdateKey,
            };
            PARAMS.push(NEW_UPDATE_KEY);
            return PARAMS;
        });
    }
    static deactivate(agent, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            const PARAMS = [];
            const AGENT = {
                vname: 'agent',
                type: 'String',
                value: agent,
            };
            PARAMS.push(AGENT);
            const SIGNATURE = {
                vname: 'signature',
                type: 'ByStr64',
                value: signature,
            };
            PARAMS.push(SIGNATURE);
            return PARAMS;
        });
    }
    static dns(domain, avatar) {
        return __awaiter(this, void 0, void 0, function* () {
            const PARAMS = [];
            const DOMAIN = {
                vname: 'domain',
                type: 'String',
                value: domain,
            };
            PARAMS.push(DOMAIN);
            const AVATAR = {
                vname: 'avatar',
                type: 'String',
                value: avatar,
            };
            PARAMS.push(AVATAR);
            return PARAMS;
        });
    }
    /** Returns a DID-Document element transition value */
    static documentElement(element, action, key, service) {
        return __awaiter(this, void 0, void 0, function* () {
            let VALUE;
            let ADD = {
                argtypes: [],
                arguments: [],
                constructor: document_model_1.Action.Adding
            };
            let REMOVE = {
                argtypes: [],
                arguments: [],
                constructor: document_model_1.Action.Removing
            };
            switch (element) {
                case document_model_1.DocumentElement.VerificationMethod:
                    VALUE = {
                        argtypes: [],
                        arguments: [],
                        constructor: "VerificationMethod"
                    };
                    switch (action) {
                        case document_model_1.Action.Adding:
                            Object.assign(VALUE, {
                                arguments: [
                                    ADD,
                                    `${key.id}`,
                                    `${key.key}`
                                ]
                            });
                            break;
                        case document_model_1.Action.Removing:
                            Object.assign(VALUE, {
                                arguments: [
                                    REMOVE,
                                    `${key.id}`,
                                    "0x024caf04aa4f660db04adf65daf5b993b3383fcdb2ef0479ca8866b1336334b5b4"
                                ]
                            });
                            break;
                    }
                    break;
                case document_model_1.DocumentElement.Service:
                    VALUE = {
                        argtypes: [],
                        arguments: [],
                        constructor: "Service"
                    };
                    let DID_SERVICE = {
                        argtypes: [],
                        arguments: [
                            `${service.type}`,
                            {
                                argtypes: [],
                                arguments: [
                                    {
                                        constructor: `${service.transferProtocol}`,
                                        argtypes: [],
                                        arguments: []
                                    },
                                    `${service.uri}`
                                ],
                                constructor: "ServiceEndpoint"
                            }
                        ],
                        constructor: "DidService"
                    };
                    switch (action) {
                        case document_model_1.Action.Adding:
                            Object.assign(VALUE, {
                                arguments: [
                                    ADD,
                                    `${service.id}`,
                                    DID_SERVICE
                                ]
                            });
                            break;
                        case document_model_1.Action.Removing:
                            Object.assign(VALUE, {
                                arguments: [
                                    REMOVE,
                                    `${service.id}`,
                                    DID_SERVICE
                                ]
                            });
                            break;
                    }
                    break;
                default:
                    throw new ErrorCode_1.default("UnsupportedElement", "That is not a DID-Document supported element");
            }
            return VALUE;
        });
    }
    static xTransfer(domain, token, agent, recipient, amount, signature) {
        return __awaiter(this, void 0, void 0, function* () {
            const PARAMS = [];
            const DOMAIN = {
                vname: 'domain',
                type: 'String',
                value: domain
            };
            PARAMS.push(DOMAIN);
            const TOKEN = {
                vname: 'token',
                type: 'String',
                value: token
            };
            PARAMS.push(TOKEN);
            const AGENT = {
                vname: 'agent',
                type: 'String',
                value: agent
            };
            PARAMS.push(AGENT);
            const RECIPIENT = {
                vname: 'to',
                type: 'ByStr20',
                value: recipient
            };
            PARAMS.push(RECIPIENT);
            const AMOUNT = {
                vname: 'amount',
                type: 'Uint128',
                value: amount,
            };
            PARAMS.push(AMOUNT);
            const SIGNATURE = {
                vname: 'signature',
                type: 'ByStr64',
                value: signature
            };
            PARAMS.push(SIGNATURE);
            return PARAMS;
        });
    }
    static ssiToken(token) {
        return __awaiter(this, void 0, void 0, function* () {
            const PARAMS = [];
            const TOKEN = {
                vname: 'token',
                type: 'String',
                value: token,
            };
            PARAMS.push(TOKEN);
            return PARAMS;
        });
    }
    static donate(campaign) {
        return __awaiter(this, void 0, void 0, function* () {
            const PARAMS = [];
            const CAMPAIGN = {
                vname: 'campaign',
                type: 'String',
                value: campaign,
            };
            PARAMS.push(CAMPAIGN);
            return PARAMS;
        });
    }
}
exports.default = TyronZIL;
var TransitionTag;
(function (TransitionTag) {
    TransitionTag["Create"] = "DidCreate";
    TransitionTag["Update"] = "DidUpdate";
    TransitionTag["Recover"] = "DidRecover";
    TransitionTag["Deactivate"] = "DidDeactivate";
    TransitionTag["Dns"] = "SetSsiDomain";
    TransitionTag["XTranfer"] = "XTransfer";
    TransitionTag["SsiToken"] = "SsiToken";
    TransitionTag["Donate"] = "Donate";
})(TransitionTag = exports.TransitionTag || (exports.TransitionTag = {}));
//# sourceMappingURL=tyronzil.js.map